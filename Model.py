#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import numpy as np
import os
from utils import dotdict


###############################################################################
args=dotdict({
        'lr':0.001,
        'dropout':0.3,
        'epochs':10,
        'batch_size':64,
        'cuda':False,
        'num_channels':512
        })


###############################################################################
from keras.models import *
from keras.layers import *
from keras.optimizers import *

class ModelSystem(object):
    def __init__(self,env):
        self.state_x,self.state_y = env.get_state_size()
        self.action_size=env.get_action_size()
        
        self.input=Input(shape=(self.state_x,self.state_y))
        imaged_input=Reshape((self.state_x,self.state_y,1))(self.input)
        
        h_conv1=Activation('relu')(BatchNormalization(axis=3)(Conv2D(args.num_channels,3,padding='same',use_bias=False,kernel_regularizer=regularizers.l2(0.0001))(imaged_input)))
        h_conv2=Activation('relu')(BatchNormalization(axis=3)(Conv2D(args.num_channels,3,padding='same',use_bias=False,kernel_regularizer=regularizers.l2(0.0001))(h_conv1)))
        h_conv3=Activation('relu')(BatchNormalization(axis=3)(Conv2D(args.num_channels,3,padding='valid',use_bias=False,kernel_regularizer=regularizers.l2(0.0001))(h_conv2)))
        h_conv4=Activation('relu')(BatchNormalization(axis=3)(Conv2D(args.num_channels,3,padding='valid',use_bias=False,kernel_regularizer=regularizers.l2(0.0001))(h_conv3)))
        
        h_conv4_flat=Flatten()(h_conv4)
        
        s_fc1=Dropout(args.dropout)(Activation('relu')(BatchNormalization(axis=1)(Dense(1024,use_bias=False,kernel_regularizer=regularizers.l2(0.0001))(h_conv4_flat))))
        s_fc2=Dropout(args.dropout)(Activation('relu')(BatchNormalization(axis=1)(Dense(512,use_bias=False,kernel_regularizer=regularizers.l2(0.0001))(s_fc1))))
        
        self.pi=Dense(self.action_size,activation='softmax',name='pi')(s_fc2)  #Policy
        self.v=Dense(1,activation='tanh',name='v')(s_fc2) #Value
        
        self.model=Model(inputs=self.input,outputs=[self.pi,self.v])
        
        self.model.compile(loss=['categorical_crossentropy','mean_squared_error'],optimizer=Adam(args.lr)) #この場合って，方策とVとでどのように誤差逆伝播がバランスされるのだろう？
    
    
    ###########################################################################
    def predict(self,canonical_state):
        pi,v=self.model.predict(canonical_state[np.newaxis,:,:])
        #KerasのInputはN*D_x*D_yであるため，np.newaxisが必要．
        return pi[0],v[0]
    
    
    ###########################################################################    
    def fit(self,experiences):
        '''
        Input:
            experiences:(canonical_state,pi,v)
            pi:policy vectore generated by MCTS
            v :actual result of game
        '''
        input_states,target_pis,target_vs=list(zip(*experiences))
        #大雑把に言えば，transpose(但し，NDArrayではないので，直接はできない)
        #experiencesはN*(state,pi,v)であるのを，N*states,N*pi,N*vに分割したい．
        #zipの引数の前の*は，展開して解釈されることを意味する．
        #つまり，先ず，*expは，zip(exp[0],exp[1],...,exp[N-1])となる．
        #zipはこれによりイテレータを生成して，[exp[n].state,exp[n].pi,exp[n].v]が出力される．
        
        input_states=np.asarray(input_states)
        target_pis=np.asarray(target_pis)
        target_vs=np.asarray(target_vs)
        
        self.model.fit(x=input_states,y=[target_pis,target_vs], \
                       batch_size=args.batch_size,epochs=args.epochs)
    
    
    ###########################################################################    
    def save_checkpoint(self,folder='checkpoint',filename='checkpoint.pth.tar'):
        filepath=os.path.join(folder,filename)
        if not os.path.exists(folder):
            print('')
            os.mkdir(folder)
        self.model.save_weights(filepath)
    
    
    ###########################################################################
    def load_checkpoint(self,folder='checkpoint',filename='checkpoint.pth.tar'):
        filepath=os.path.join(folder,filename)
        if not os.path.exists(filepath):
            raise('No model in path')
        self.model.load_weights(filepath)

